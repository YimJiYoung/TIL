# Object Oriented programming
프로그램을 명령어의 목록으로 보는 기존의 절차 지향적인 시각으로 벗어나 **독립적인 단위인 객체들의 협력**으로 보는 것
- 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.
- 자율적인 객체란 상태와 행위를 함게 지니며 자신의 행동을 스스로 결정하고 책임지는 객체를 의미한다.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력하며 각 객체는 협력 내에서 정해진 역할(관려된 책임의 집합)을 수행한다.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 메서드를 자율적으로 선택한다. (객체의 자율성)

<br />

## 타입과 추상화

### 추상화
어떤 세부 사항이나 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법 → 단순화
- 구체적인 사물들 간의 공통점을 취하고 차이점은 버리는 일반화
- 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함

### 타입(개념)
공통점을 기반으로 객체들을 묶기 위한 그릇은 개념이며, 개념을 이용하여 객체를 여러 그룹으로 분류할 수 있다.
객체에 어떤 개념을 적용하여 개념 그룹의 일원일 될 때 객체를 그 개념의 인스턴스라고 한다.

- 객체의 타입을 결정하는 것은 객체의 행동이다.
  - 객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동(동일한 책임을 수행)한다면 동일한 타입에 속한다.
- 객체의 내부적인 표현(구현)은 외부로부터 철저하게 감춰진다.

### 캡슐화
객체가 외부에 제공해야 하는 행동만을 외부에 제공하고 데이터는 감춰야 한다.

### 일반화/특수화
일반적인 타입(슈퍼타입)은 특수한 타입보다 적은 수의 행동을 가지고 특수한 타입(서브타입)은 일반적인 타입보다 더 많은 수의 행동(자신에게 특수화된 추가적인 행동)을 가진다.
서브타입은 슈퍼타입을 대체할 수 있어야 한다.

### 클래스
객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.
동일한 타입에 속하는 객체는 동일한 클래스의 인스턴스여야 한다. 

<br />

## 역할, 책임, 협력
- 협력: 다수의 연쇄적인 요청과 응답의 흐름응로 구성된다. 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.
- 첵임: 협력에 참여하기 위해 객체가 수행하는 행동. 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 객체는 해당 책임을 가진다고 할 수 있다.
   - 객체에 의해 정의되는 응집도 있는 행위의 집합: 객체가 알아야 하는 정보 + 객체가 수행할 수 있는 행위
   - 객체의 외부에 제공해줄 수 있는 정보와 외부에 제공해 줄 수 있는 서비스의 목록 → **공용 인터페이스**
- 역할: 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 의미하며 역할은 협력 내에서 다른 객체로 대체할 수 있다 → 재사용성, 유연성
   - 얘시) '판사' 역할에는 하트 왕이나 하트 여왕이 대신할 수 있다.
   - 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정된다. (동일한 역할 = 동일한 책임의 집합 수행)

<br />

## 책임과 메시지

### 자율적인 책임
객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이며 요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다.
**자율적인 책임의 특징은 어떻게 해야 하는가가 아니라 무엇을 해야 하는가를 설명한다**는 것이다. 책임을 수행할 방법은 객체가 자율적으로 선택할 수 있다.

### 메시지
객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐이며 이를 메시지라고 한다.
따라서 객체가 유일하게 이해할 수 있는 의사소통 수단은 메시지뿐이며 메시지를 처리하기 위한 방법은 자율적으로 선택할 수 있다.

### 메서드
객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 메서드라고 한다. 어떤 객체에게 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행된다.

### 다형성
서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘
- 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것 → 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성
- 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다. → 수신자의 종류 캡슐화

### 인터페이스
어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치
- 인터페이스의 사용법만 알고 있으면 대상의 내부 구조나 동작 방법은 몰라도 상호작용이 가능하다.
- 인터페이스가 변경되지 않고 단순히 내부 구성이나 작동 방식이 변경되는 것은 인터페이스 사용자에게 아무런 영향도 미치지 않는다.
- 인터페이스가 동일하기만 한다면 어떤 대상과도 상호작용할 수 있다.

> 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이므로 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성된다.

### 공용 인터페이스
외부에서 접근 가능한 공개된 인터페이스. 객체의 공용 인터페이스를 구성하는 것은 객체가 외부로부터 수신할 수 있는 메시지의 목록이다.

### 인터페이스와 구현의 분리
- 객체의 자율성을 보장하기 위한 추상적인 인터페이스
  - 세부 사항을 제거하고 메시지의 의도를 표현 → 추상화
- 최소 인터페이스
  - 외부에서 사용할 필요가 없는 인터페이스는 노출하지 않는다 →  객체의 내부를 수정하더라도 외부에 미치는 영향 최소화
- 인터페이스와 구현과의 차이
  - 구현: 내부 구조와 작동 방식을 의미하며 객체를 구성하지만 공용 인터페이스에는 포함되지 않는 것 (객체의 상태, 메서드 등)
  - 훌륭한 객체는 구현은 모른 채 인터페이스만 알면 쉽게 상효작용할 수 있는 객체이다.
 
### 캡술화
객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것
- 상태와 행위의 캡술화
  - 상태와 행위를 한데 묶은 후 외부에서 반드시 접근해야만 행위만 골라 공용 인터페이스를 통해 노출
- 사적인 비밀의 캡슐화(정보 은닉)
  - 외부의 객체가 자신의 내부 상태를 직접 관찰하거나 제어할 수 없도록 막는다.


<br />

## 설계 품질

### 응집도 
모듈에 포함된 내부 요소들이 연관돼 있는 정도(변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도)
- 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 변경된다면 응집도 낮음
![응집도](https://wikibook.co.kr/images/errata/object/object-4-2.png)

### 결합도
한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도(의존성의 정도)

### 의존성
어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재한다.
의존디는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다(변경에 의한 전파 가능성 암시)

#### 런타임 의존성
애플리케이션 실행 시점의 객체(클래스의 인스턴스) 사이의 의존성

#### 컴파일타임 의존성
코드 작성 시점의 클래스 사이의 의존성

```
- 런타임 의존성 : Movie 인스턴스는 AmountDiscountPolicy or PercentDiscountPolicy의 인스턴스와 협력
- 컴파일 의존성 : Movie 클래스는 추상 클래스인 DiscountPolicy에 의존

 Movie ――――――――> DiscountPolicy
                       ^
                       | 
                       | 
                  ――――――――――――
                  |          | 
               Amount       Percent
         DiscountPolicy    DiscountPolicy
```

> 런타임과 컴파일타임 의존성은 다를 수 있다. 유연하고 재사용가능한 코드를 설계하기 위해서는 두 종류의 의존성을 다르게 만들어야 한다.

#### 의존성 해결
컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체
의존성은 명시적으로(퍼블릭 인터페이스에) 표현돼야 좋다.

- 객체 생성 시점에 생성자를 통해
- 객체 생성 후 setter 메서드를 통해
- 메서드 실행 시 인자를 이용해


 <br />
 
## 설계 원칙

### 개방-폐쇄 원칙
소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계가 좋은(유연한) 설계이다. 
- `확장에 대해 열려 있다` : 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- `수정에 대해 닫혀 있다` : 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

#### 핵심은 추상화
문맥이 바뀌더라도 변하지 않는 부분(다양한 상황에서의 공통점을 반영한 부분)만을 남기고 불필요한 부분을 생략한 추상화에 의존하면 문맥이 변하더라도 수정할 필요가 없어진다.
- 수정에 대한 영향을 최소하히기 위해서는 모든 요소가 추상화에 의존해야 한다.

### 의존성 역전 원칙
- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다.
   - 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 된다.
   - 둘 모두 추상화에 의존하게 하는 것이 좋은 설계이다.
- 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항이 추상화에 의존해야 한다.


 <br />
 
## 상속과 코드 재사용
이미 존재하는 클래스와 유사한 클래스가 필요하다면 상속을 이용해 코드를 재사용할 수 있다. 그러나 상속은 부모 클래스와 자식 클래스 사이의 강한 결합을 초래하기 때문에 주의해서 써야한다.

### 취약한 기반 클래스 문제(Fragile Base Class Problem)
부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상
- 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다

1. 불필요한 인터페이스 상속 문제
  - 예시 ) `Vector: get(index), add(index, element), remove(index)`의 퍼블릭 인터페이스를 그대로 상속받는 `Stack`
  - 퍼블릭 인터페이스에 대한 고려 없이 단순히 코드 재사용을 위해 상속을 사용하는 것은 지양하자.
  - 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

2. 메서드 오버라이딩의 오작용 문제
  - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

3. 부모 클래스와 자식 클래스의 동시 수정 문제

### 추상화에 의존 / 차이에 의한 프로그래밍
취약한 기반 클래스 문제를 완화하기 위한 해결 방법은 추상화이다. 자식 클래스가 부모클래스의 구현이 아닌 추상화에 의존하도록 만들자.

#### 차이를 메서드로 추출하고 중복 코드를 부모 클래스로 올려라

#### 추상 클래스
구현이 제공되지 않은 추상 메서드를 포함하는 클래스를 말하며 해당 클래스의 인스턴스는 생성할 수 없다.
추상 클래스를 상속받는 자식 클래스에게 추상 메서드를 구현(오버라이딩)하도록 한다.

- 아래와 같이 부모 클래스에 기본적인 알고리즘의 흐름(자식 클래스들 사이의 공통점)을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임할 수 있다.
```tsx
abstract class DiscountPolicy {
  private conditions: DiscountCondition[] = [];
  
  abstract getDiscountAmount(screening: Screening): number;
  
  constructor(...conditions: DiscountCondition[]) {
    this.conditions = conditions;
  }
 
  calculateDiscountAmount(screening: Screening) {
    for (const condition of conditions) {
      if(condition.isSatisfiedBy(screening)) {
        return getDiscountAmount(screening);
      }
    }
    
    return 0;
  }
}
```


 <br />

## 🔗참고
객체지향의 사실과 오해 - 조용호 
오브젝트
