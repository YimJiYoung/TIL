# Object Oriented programming
프로그램을 명령어의 목록으로 보는 기존의 절차 지향적인 시각으로 벗어나 **독립적인 단위인 객체들의 협력**으로 보는 것
- 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.
- 자율적인 객체란 상태와 행위를 함게 지니며 자신의 행동을 스스로 결정하고 책임지는 객체를 의미한다.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력하며 각 객체는 협력 내에서 정해진 역할(관려된 책임의 집합)을 수행한다.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 메서드를 자율적으로 선택한다. (객체의 자율성)

<br />

## 타입과 추상화

### 추상화
어떤 세부 사항이나 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법 → 단순화
- 구체적인 사물들 간의 공통점을 취하고 차이점은 버리는 일반화
- 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함

### 타입(개념)
공통점을 기반으로 객체들을 묶기 위한 그릇은 개념이며, 개념을 이용하여 객체를 여러 그룹으로 분류할 수 있다.
객체에 어떤 개념을 적용하여 개념 그룹의 일원일 될 때 객체를 그 개념의 인스턴스라고 한다.

- 객체의 타입을 결정하는 것은 객체의 행동이다.
  - 객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동(동일한 책임을 수행)한다면 동일한 타입에 속한다.
- 객체의 내부적인 표현(구현)은 외부로부터 철저하게 감춰진다.

### 캡슐화
객체가 외부에 제공해야 하는 행동만을 외부에 제공하고 데이터는 감춰야 한다.

### 일반화/특수화
일반적인 타입(슈퍼타입)은 특수한 타입보다 적은 수의 행동을 가지고 특수한 타입(서브타입)은 일반적인 타입보다 더 많은 수의 행동(자신에게 특수화된 추가적인 행동)을 가진다.
서브타입은 슈퍼타입을 대체할 수 있어야 한다.

### 클래스
객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.
동일한 타입에 속하는 객체는 동일한 클래스의 인스턴스여야 한다. 

<br />

## 역할, 책임, 협력
- 협력: 다수의 연쇄적인 요청과 응답의 흐름응로 구성된다. 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.
- 첵임: 협력에 참여하기 위해 객체가 수행하는 행동. 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 객체는 해당 책임을 가진다고 할 수 있다.
   - 객체에 의해 정의되는 응집도 있는 행위의 집합: 객체가 알아야 하는 정보 + 객체가 수행할 수 있는 행위
   - 객체의 외부에 제공해줄 수 있는 정보와 외부에 제공해 줄 수 있는 서비스의 목록 → **공용 인터페이스**
- 역할: 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 의미하며 역할은 협력 내에서 다른 객체로 대체할 수 있다 → 재사용성, 유연성
   - 얘시) '판사' 역할에는 하트 왕이나 하트 여왕이 대신할 수 있다.
   - 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정된다. (동일한 역할 = 동일한 책임의 집합 수행)

<br />

## 책임과 메시지

### 자율적인 책임
객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이며 요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다.
**자율적인 책임의 특징은 어떻게 해야 하는가가 아니라 무엇을 해야 하는가를 설명한다**는 것이다. 책임을 수행할 방법은 객체가 자율적으로 선택할 수 있다.

### 메시지
객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐이며 이를 메시지라고 한다.
따라서 객체가 유일하게 이해할 수 있는 의사소통 수단은 메시지뿐이며 메시지를 처리하기 위한 방법은 자율적으로 선택할 수 있다.

### 메서드
객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 메서드라고 한다. 어떤 객체에게 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행된다.

### 다형성
서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘
- 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것 → 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성
- 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다. → 수신자의 종류 캡슐화

### 인터페이스
어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치
- 인터페이스의 사용법만 알고 있으면 대상의 내부 구조나 동작 방법은 몰라도 상호작용이 가능하다.
- 인터페이스가 변경되지 않고 단순히 내부 구성이나 작동 방식이 변경되는 것은 인터페이스 사용자에게 아무런 영향도 미치지 않는다.
- 인터페이스가 동일하기만 한다면 어떤 대상과도 상호작용할 수 있다.

> 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이므로 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성된다.

### 공용 인터페이스
외부에서 접근 가능한 공개된 인터페이스. 객체의 공용 인터페이스를 구성하는 것은 객체가 외부로부터 수신할 수 있는 메시지의 목록이다.

### 인터페이스와 구현의 분리
- 객체의 자율성을 보장하기 위한 추상적인 인터페이스
  - 세부 사항을 제거하고 메시지의 의도를 표현 → 추상화
- 최소 인터페이스
  - 외부에서 사용할 필요가 없는 인터페이스는 노출하지 않는다 →  객체의 내부를 수정하더라도 외부에 미치는 영향 최소화
- 인터페이스와 구현과의 차이
  - 구현: 내부 구조와 작동 방식을 의미하며 객체를 구성하지만 공용 인터페이스에는 포함되지 않는 것 (객체의 상태, 메서드 등)
  - 훌륭한 객체는 구현은 모른 채 인터페이스만 알면 쉽게 상효작용할 수 있는 객체이다.
 
### 캡술화
객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것
- 상태와 행위의 캡술화
  - 상태와 행위를 한데 묶은 후 외부에서 반드시 접근해야만 행위만 골라 공용 인터페이스를 통해 노출
- 사적인 비밀의 캡슐화(정보 은닉)
  - 외부의 객체가 자신의 내부 상태를 직접 관찰하거나 제어할 수 없도록 막는다.


<br />

## 설계 품질

### 응집도 
모듈에 포함된 내부 요소들이 연관돼 있는 정도(변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도)
- 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 변경된다면 응집도 낮음
![응집도](https://wikibook.co.kr/images/errata/object/object-4-2.png)

### 결합도
한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도(의존성의 정도)

 <br />
 
## 설계 원칙

### 개방-폐쇄 원칙
소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

#### 핵심은 추상화
문맥이 바뀌더라도 변하지 않는 부분(다양한 상황에서의 공통점을 반영한 부분)만을 남기고 불필요한 부분을 생략한 추상화에 의존하면 문맥이 변하더라도 수정할 필요가 없어진다.
- 수정에 대한 영향을 최소하히기 위해서는 모든 요소가 추상화에 의존해야 한다.

## 🔗참고
객체지향의 사실과 오해 - 조용호 
오브젝트
